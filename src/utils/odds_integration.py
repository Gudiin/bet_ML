"""
MÃ³dulo de IntegraÃ§Ã£o: Odds Reais + Modelo de ML

Este mÃ³dulo integra o scraper de odds da Superbet com o modelo de ML,
permitindo a validaÃ§Ã£o do ROI com dados reais de apostas.

Uso:
    from src.utils.odds_integration import OddsIntegrator
    
    integrator = OddsIntegrator()
    df_with_odds = integrator.fetch_and_validate_odds(urls)
    roi = integrator.calculate_roi_from_predictions(predictions, df_with_odds)

Autor: Manus AI
Data: 2025-12-11
"""

import asyncio
import pandas as pd
import numpy as np
import logging
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from datetime import datetime

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class OddsIntegrator:
    """
    Integra odds reais com previsÃµes do modelo de ML.
    
    Responsabilidades:
    1. Fetch de odds (via scraper ou API)
    2. ValidaÃ§Ã£o e limpeza de dados de odds
    3. CÃ¡lculo de ROI baseado em apostas +EV
    4. GeraÃ§Ã£o de relatÃ³rios de performance
    """
    
    def __init__(self, scraper=None):
        """
        Inicializa o integrador.
        
        Args:
            scraper: InstÃ¢ncia do SuperbetOddsScraper (opcional)
        """
        self.scraper = scraper
        self.odds_cache = {}
    
    async def fetch_odds_for_matches(self, match_urls: List[str]) -> pd.DataFrame:
        \"\"\"\n        Busca odds para uma lista de partidas.\n        \n        Args:\n            match_urls: Lista de URLs de partidas\n        \n        Returns:\n            DataFrame com as odds extraÃ­das\n        \"\"\"\n        if not self.scraper:\n            from src.scrapers.superbet_odds_scraper import SuperbetOddsScraper\n            self.scraper = SuperbetOddsScraper(headless=True)\n        \n        try:\n            df_odds = await self.scraper.extract_odds_batch(match_urls)\n            logger.info(f\"âœ… {len(df_odds)} odds obtidas com sucesso.\")\n            return df_odds\n        \n        except Exception as e:\n            logger.error(f\"âŒ Erro ao buscar odds: {str(e)}\")\n            return pd.DataFrame()\n    \n    def validate_odds(self, df_odds: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Valida e limpa dados de odds.\n        \n        Args:\n            df_odds: DataFrame com odds brutos\n        \n        Returns:\n            DataFrame com odds validadas\n        \"\"\"\n        df_clean = df_odds.copy()\n        \n        # Remove linhas com odds invÃ¡lidas\n        df_clean = df_clean[\n            (df_clean['over_odds'] > 1.0) & \n            (df_clean['under_odds'] > 1.0) &\n            (df_clean['line'].notna())\n        ]\n        \n        # Valida que as odds estÃ£o dentro de um intervalo razoÃ¡vel\n        df_clean = df_clean[\n            (df_clean['over_odds'] >= 1.01) & \n            (df_clean['over_odds'] <= 50.0) &\n            (df_clean['under_odds'] >= 1.01) & \n            (df_clean['under_odds'] <= 50.0)\n        ]\n        \n        # Valida que a linha estÃ¡ em um intervalo razoÃ¡vel (0 a 20 escanteios)\n        df_clean = df_clean[\n            (df_clean['line'] >= 0) & \n            (df_clean['line'] <= 20)\n        ]\n        \n        logger.info(f\"âœ… {len(df_clean)} odds validadas (removidas {len(df_odds) - len(df_clean)} invÃ¡lidas).\")\n        \n        return df_clean\n    \n    def merge_predictions_with_odds(\n        self, \n        predictions: np.ndarray, \n        df_odds: pd.DataFrame,\n        y_true: Optional[np.ndarray] = None\n    ) -> pd.DataFrame:\n        \"\"\"\n        Mescla previsÃµes do modelo com dados de odds.\n        \n        Args:\n            predictions: Array com previsÃµes do modelo\n            df_odds: DataFrame com odds\n            y_true: Array com valores reais (opcional, para backtesting)\n        \n        Returns:\n            DataFrame mesclado\n        \"\"\"\n        df_merged = df_odds.copy()\n        df_merged['prediction'] = predictions[:len(df_merged)]\n        \n        if y_true is not None:\n            df_merged['actual'] = y_true[:len(df_merged)]\n        \n        return df_merged\n    \n    def calculate_ev_bets(\n        self, \n        df_merged: pd.DataFrame,\n        margin: float = 0.05\n    ) -> pd.DataFrame:\n        \"\"\"\n        Identifica apostas com Valor Esperado Positivo (+EV).\n        \n        Args:\n            df_merged: DataFrame com previsÃµes e odds\n            margin: Margem de seguranÃ§a (5% por padrÃ£o)\n        \n        Returns:\n            DataFrame com apenas as apostas +EV\n        \"\"\"\n        from scipy.stats import poisson\n        \n        df_ev = df_merged.copy()\n        \n        # Calcula probabilidades do modelo usando Poisson\n        df_ev['model_prob_over'] = df_ev['prediction'].apply(\n            lambda pred: 1 - poisson.cdf(k=df_ev['line'].iloc[0], mu=pred)\n        )\n        \n        df_ev['model_prob_under'] = df_ev['prediction'].apply(\n            lambda pred: poisson.cdf(k=df_ev['line'].iloc[0], mu=pred)\n        )\n        \n        # Calcula probabilidades implÃ­citas das odds\n        df_ev['bookie_prob_over'] = 1 / df_ev['over_odds']\n        df_ev['bookie_prob_under'] = 1 / df_ev['under_odds']\n        \n        # Identifica apostas +EV\n        df_ev['is_over_ev'] = df_ev['model_prob_over'] > df_ev['bookie_prob_over'] * (1 + margin)\n        df_ev['is_under_ev'] = df_ev['model_prob_under'] > df_ev['bookie_prob_under'] * (1 + margin)\n        \n        # Filtra apenas apostas +EV\n        df_ev_only = df_ev[df_ev['is_over_ev'] | df_ev['is_under_ev']].copy()\n        \n        logger.info(f\"âœ… {len(df_ev_only)} apostas +EV identificadas de {len(df_ev)} total.\")\n        \n        return df_ev_only\n    \n    def simulate_betting(\n        self,\n        df_ev: pd.DataFrame,\n        stake: float = 1.0\n    ) -> Dict:\n        \"\"\"\n        Simula apostas baseadas nas oportunidades +EV.\n        \n        Args:\n            df_ev: DataFrame com apostas +EV\n            stake: Valor da aposta unitÃ¡ria\n        \n        Returns:\n            DicionÃ¡rio com estatÃ­sticas de betting\n        \"\"\"\n        results = {\n            'total_bets': 0,\n            'total_wins': 0,\n            'total_losses': 0,\n            'total_profit': 0.0,\n            'win_rate': 0.0,\n            'roi': 0.0,\n            'roi_percent': 0.0,\n            'avg_odds': 0.0,\n            'bets': []\n        }\n        \n        if df_ev.empty:\n            logger.warning(\"âš ï¸ Nenhuma aposta +EV para simular.\")\n            return results\n        \n        total_odds = 0\n        \n        for idx, row in df_ev.iterrows():\n            bet = {\n                'match': row.get('match_name', 'Unknown'),\n                'type': 'Over' if row['is_over_ev'] else 'Under',\n                'line': row['line'],\n                'odds': row['over_odds'] if row['is_over_ev'] else row['under_odds'],\n                'stake': stake,\n            }\n            \n            # Determina resultado (se y_true disponÃ­vel)\n            if 'actual' in row and pd.notna(row['actual']):\n                actual = row['actual']\n                line = row['line']\n                \n                if bet['type'] == 'Over':\n                    is_win = actual > line\n                else:\n                    is_win = actual <= line\n                \n                bet['result'] = 'WIN' if is_win else 'LOSS'\n                bet['profit'] = (bet['odds'] - 1) * stake if is_win else -stake\n                \n                results['total_bets'] += 1\n                total_odds += bet['odds']\n                \n                if is_win:\n                    results['total_wins'] += 1\n                    results['total_profit'] += bet['profit']\n                else:\n                    results['total_losses'] += 1\n                    results['total_profit'] -= stake\n            \n            results['bets'].append(bet)\n        \n        # Calcula mÃ©tricas finais\n        if results['total_bets'] > 0:\n            results['win_rate'] = results['total_wins'] / results['total_bets']\n            results['roi'] = results['total_profit'] / (results['total_bets'] * stake)\n            results['roi_percent'] = results['roi'] * 100\n            results['avg_odds'] = total_odds / results['total_bets']\n        \n        return results\n    \n    def generate_report(\n        self,\n        df_merged: pd.DataFrame,\n        betting_results: Dict,\n        output_path: Optional[str] = None\n    ) -> str:\n        \"\"\"\n        Gera um relatÃ³rio detalhado de performance.\n        \n        Args:\n            df_merged: DataFrame com previsÃµes e odds\n            betting_results: Resultados da simulaÃ§Ã£o de apostas\n            output_path: Caminho para salvar o relatÃ³rio (opcional)\n        \n        Returns:\n            String com o relatÃ³rio\n        \"\"\"\n        report = f\"\"\"\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘           RELATÃ“RIO DE PERFORMANCE - ODDS REAIS               â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nğŸ“Š ESTATÃSTICAS GERAIS\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTotal de Partidas Analisadas:  {len(df_merged)}\nApostas +EV Identificadas:     {betting_results['total_bets']}\nTaxa de Cobertura:             {(betting_results['total_bets'] / len(df_merged) * 100):.1f}%\n\nğŸ’° RESULTADOS DE APOSTAS\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTotal de Apostas:              {betting_results['total_bets']}\nVitÃ³rias:                      {betting_results['total_wins']}\nDerrotas:                      {betting_results['total_losses']}\nWin Rate:                      {betting_results['win_rate']:.2%}\n\nğŸ“ˆ RETORNO FINANCEIRO\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nLucro Total:                   {betting_results['total_profit']:+.2f} unidades\nROI (Retorno):                 {betting_results['roi']:+.2f} unidades\nROI (%):                       {betting_results['roi_percent']:+.1f}%\nOdd MÃ©dia:                     {betting_results['avg_odds']:.2f}\n\nğŸ¯ INTERPRETAÃ‡ÃƒO\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\"\"\"\n        \n        if betting_results['roi_percent'] > 15:\n            report += \"âœ… EXCELENTE! ROI acima de 15%. Modelo tem potencial lucrativo.\\n\"\n        elif betting_results['roi_percent'] > 5:\n            report += \"ğŸŸ¡ BOM! ROI positivo. Modelo Ã© viÃ¡vel com gestÃ£o de banca.\\n\"\n        elif betting_results['roi_percent'] > 0:\n            report += \"ğŸŸ  MARGINAL. ROI positivo mas baixo. Requer otimizaÃ§Ã£o.\\n\"\n        else:\n            report += \"ğŸ”´ NEGATIVO. Modelo nÃ£o Ã© lucrativo. Revisar features/parÃ¢metros.\\n\"\n        \n        report += f\"\"\"\n\nğŸ“‹ PRÃ“XIMOS PASSOS\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1. Validar em dados mais recentes (fora da amostra de treinamento)\n2. Testar em ambiente de paper trading (sem dinheiro real)\n3. Ajustar tamanho de apostas usando CritÃ©rio de Kelly\n4. Monitorar performance em tempo real\n5. Rebalancear modelo periodicamente com novos dados\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nRelatÃ³rio gerado em: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\"\"\"\n        \n        if output_path:\n            Path(output_path).parent.mkdir(parents=True, exist_ok=True)\n            with open(output_path, 'w', encoding='utf-8') as f:\n                f.write(report)\n            logger.info(f\"âœ… RelatÃ³rio salvo em: {output_path}\")\n        \n        return report\n\n\nasync def main():\n    \"\"\"\n    Exemplo de uso do integrador.\n    \"\"\"\n    # Importa o scraper\n    from src.scrapers.superbet_odds_scraper import SuperbetOddsScraper\n    \n    scraper = SuperbetOddsScraper(headless=True)\n    integrator = OddsIntegrator(scraper=scraper)\n    \n    try:\n        # URLs de exemplo (vocÃª pode adicionar mais)\n        urls = [\n            \"https://superbet.bet.br/odds/futebol/arsenal-x-wolverhampton-8627842/?t=offer-prematch-106&mdt=o\",\n        ]\n        \n        # Busca odds\n        df_odds = await integrator.fetch_odds_for_matches(urls)\n        \n        if not df_odds.empty:\n            # Valida odds\n            df_odds_clean = integrator.validate_odds(df_odds)\n            \n            # Simula previsÃµes (em produÃ§Ã£o, viriam do modelo)\n            predictions = np.random.uniform(8, 12, len(df_odds_clean))\n            \n            # Mescla com previsÃµes\n            df_merged = integrator.merge_predictions_with_odds(predictions, df_odds_clean)\n            \n            # Identifica apostas +EV\n            df_ev = integrator.calculate_ev_bets(df_merged)\n            \n            # Simula apostas\n            results = integrator.simulate_betting(df_ev)\n            \n            # Gera relatÃ³rio\n            report = integrator.generate_report(df_merged, results)\n            print(report)\n    \n    finally:\n        await scraper.close()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n
