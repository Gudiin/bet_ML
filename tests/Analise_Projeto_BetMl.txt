# RELATÃ“RIO TÃ‰CNICO: ARQUITETURA E DATA SCIENCE (BET ML)
**Data:** 04/12/2025
**Autor:** Arquiteto de Software & Data Scientist SÃªnior
**Status:** AnÃ¡lise CrÃ­tica do Projeto

---

## 1. ANÃLISE DE VULNERABILIDADES E PONTOS CRÃTICOS

ApÃ³s revisÃ£o profunda dos mÃ³dulos `model_v2.py`, `features_v2.py` e `statistical.py`, identifiquei simplificaÃ§Ãµes que podem comprometer a lucratividade real em produÃ§Ã£o.

### ðŸš¨ A. A IlusÃ£o da "Linha Fixa" (Risco de NegÃ³cio CrÃ­tico)
**Onde:** `model_v2.py` (MÃ©todo `_evaluate_profitability`)
- **O Problema:** O cÃ³digo assume uma linha fixa (`line = 9.5`) e odd fixa (`avg_odd = 1.90`) para todos os jogos.
- **Realidade:** As casas de apostas ajustam a linha baseada na expectativa. Um jogo ofensivo pode ter linha 11.5, enquanto um defensivo tem 8.5.
- **Risco:** Seu modelo pode prever 10 escanteios e marcar como "Green" (porque 10 > 9.5), mas se a linha da casa for 10.5, seria um "Red". Isso infla artificialmente o ROI do seu backtest.
- **CorreÃ§Ã£o:** O backtest deve consumir a linha de fechamento real (Closing Line) ou estimÃ¡-la com base na mÃ©dia histÃ³rica dos times.

### ðŸ“‰ B. IndependÃªncia EstatÃ­stica (Falha no Monte Carlo)
**Onde:** `statistical.py` (MÃ©todo `simulate_match_event`)
- **O CÃ³digo:** `sim_home + sim_away` (Soma simples).
- **O Problema:** Assume que o desempenho do Time A Ã© independente do Time B. No futebol, escanteios tÃªm correlaÃ§Ã£o dinÃ¢mica (Game State). Se o Time A faz um gol cedo, ele recua (menos escanteios), e o Time B ataca (mais escanteios).
- **Risco:** Probabilidades imprecisas para mercados de totais e handicaps.

### â³ C. ValidaÃ§Ã£o EstÃ¡tica (Hold-Out) vs. Sazonalidade
**Onde:** `model_v2.py` (MÃ©todo `train_time_series_split`)
- **O Problema:** Usa um corte simples (treina nos primeiros 80%, testa nos Ãºltimos 20%).
- **Risco:** Testa o modelo apenas em uma "fatia" do tempo. Se o perÃ­odo de teste coincidir com final de temporada (onde a dinÃ¢mica de jogo muda), as mÃ©tricas estarÃ£o enviesadas e nÃ£o refletirÃ£o o longo prazo.

---

## 2. ROADMAP DE EVOLUÃ‡ÃƒO (DATA SCIENCE)

### ðŸŸ¢ NÃVEL 1: CorreÃ§Ãµes Imediatas (FundaÃ§Ã£o)

1.  **Feature Engineering - ForÃ§a do Oponente (Strength of Schedule)**
    * *Atual:* Usa mÃ©dias absolutas (`avg_corners`).
    * *AÃ§Ã£o:* Criar features relativas. Fazer 10 escanteios contra o lÃ­der Ã© melhor que contra o lanterna.
    * *Nova Feature:* `corners_made_vs_league_avg_conceded`.

2.  **SeparaÃ§Ã£o Home/Away Rigorosa**
    * *AÃ§Ã£o:* Calcular mÃ©dias separadas. O comportamento de um time em casa Ã© drasticamente diferente de fora.
    * *Features:* `avg_corners_home_l5` e `avg_corners_away_l5`.

3.  **Walk-Forward Validation (Substituir Split 80/20)**
    * *AÃ§Ã£o:* Implementar validaÃ§Ã£o em janelas deslizantes. Treina Jan-Mar -> Testa Abril. Treina Jan-Abril -> Testa Maio.

### ðŸŸ¡ NÃVEL 2: OtimizaÃ§Ã£o (Performance)

4.  **OtimizaÃ§Ã£o Bayesiana (Optuna)**
    * *AÃ§Ã£o:* Substituir `GridSearchCV` por **Optuna**.
    * *Objetivo:* Deixar a IA descobrir nÃ£o sÃ³ os hiperparÃ¢metros do LightGBM, mas tambÃ©m o tamanho ideal das janelas de mÃ©dia mÃ³vel (ex: talvez 6 jogos seja melhor que 5).

5.  **RegressÃ£o QuantÃ­lica (Margem de SeguranÃ§a)**
    * *AÃ§Ã£o:* Usar `objective='quantile'` no LightGBM.
    * *EstratÃ©gia:* Prever o cenÃ¡rio pessimista (P10) e o otimista (P90). SÃ³ apostar se o cenÃ¡rio pessimista ainda for superior Ã  linha da casa.

### ðŸ”´ NÃVEL 3: Estado da Arte (MatemÃ¡tica Pura)

6.  **DistribuiÃ§Ã£o de Poisson Bivariada (Dixon-Coles)**
    * *AÃ§Ã£o:* Substituir a soma simples no Monte Carlo por uma distribuiÃ§Ã£o que modele a correlaÃ§Ã£o $\rho$ entre os times.
    * *FÃ³rmula:* $P(X, Y) \sim BivPoisson(\lambda_1, \lambda_2, \rho)$.

---

## 3. EXEMPLO DE CÃ“DIGO: WALK-FORWARD VALIDATION

Abaixo, a refatoraÃ§Ã£o sugerida para o mÃ©todo de treinamento em `model_v2.py` para garantir robustez temporal.

```python
from sklearn.model_selection import TimeSeriesSplit
import numpy as np
import pandas as pd
import lightgbm as lgb

def train_walk_forward(self, X: pd.DataFrame, y: pd.Series, timestamps: pd.Series, n_splits: int = 5):
    """
    Realiza validaÃ§Ã£o Walk-Forward para simular o cenÃ¡rio real de apostas.
    Re-treina o modelo periodicamente Ã  medida que o tempo avanÃ§a.
    """
    print(f"\nðŸš€ INICIANDO WALK-FORWARD VALIDATION ({n_splits} FOLDS)")
    print("="*70)

    # Garante ordenaÃ§Ã£o temporal absoluta
    df_full = pd.concat([X, y, timestamps.rename('ts')], axis=1).sort_values('ts')
    
    # Remove colunas auxiliares para treino
    X_sorted = df_full[X.columns]
    y_sorted = df_full[y.name]
    
    tscv = TimeSeriesSplit(n_splits=n_splits)
    
    metrics = []
    
    for fold, (train_idx, test_idx) in enumerate(tscv.split(X_sorted)):
        # SeparaÃ§Ã£o temporal
        X_train, X_test = X_sorted.iloc[train_idx], X_sorted.iloc[test_idx]
        y_train, y_test = y_sorted.iloc[train_idx], y_sorted.iloc[test_idx]
        
        # PerÃ­odo do teste atual
        test_start = df_full.iloc[test_idx]['ts'].min()
        test_end = df_full.iloc[test_idx]['ts'].max()
        
        # Treinamento (sempre re-treinando do zero com mais dados)
        model = lgb.LGBMRegressor(**self.default_params)
        model.fit(
            X_train, 
            y_train,
            eval_set=[(X_test, y_test)],
            eval_metric='mae',
            callbacks=[lgb.early_stopping(stopping_rounds=30, verbose=False)]
        )
        
        # PrevisÃ£o e AvaliaÃ§Ã£o
        preds = model.predict(X_test)
        
        # Calcula ROI deste perÃ­odo especÃ­fico
        # Nota: Assume _evaluate_profitability retorna um dict com 'roi_percent'
        roi_data = self._evaluate_profitability(y_test, preds)
        
        print(f"ðŸ“‚ FOLD {fold+1}: {test_start.date()} atÃ© {test_end.date()} | ROI: {roi_data['roi_percent']:+.2f}%")
        metrics.append(roi_data['roi_percent'])

    # Resultados Finais
    avg_roi = np.mean(metrics)
    std_roi = np.std(metrics)
    
    print("="*70)
    print(f"ðŸ“Š RESULTADO FINAL WALK-FORWARD")
    print(f"ðŸ’° ROI MÃ©dio Esperado: {avg_roi:+.2f}%")
    print(f"ðŸ“‰ Volatilidade (Risco): Â±{std_roi:.2f}%")
    
    if avg_roi > 5.0 and std_roi < 10.0:
        print("âœ… MODELO APROVADO PARA PAPER TRADING")
    else:
        print("âŒ MODELO INSTÃVEL - REVISAR FEATURES")